// Code generated by protoc-gen-box. DO NOT EDIT.
// source: searchd.proto

package searchdpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import pb "github.com/tddhit/xsearch/pb"

import (
	tr "github.com/tddhit/box/transport"
	tropt "github.com/tddhit/box/transport/option"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import (
	context1 "golang.org/x/net/context"
	grpc1 "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type InfoReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InfoReq) Reset()         { *m = InfoReq{} }
func (m *InfoReq) String() string { return proto.CompactTextString(m) }
func (*InfoReq) ProtoMessage()    {}
func (*InfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_searchd_b57a8c9ce0eb4055, []int{0}
}
func (m *InfoReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InfoReq.Unmarshal(m, b)
}
func (m *InfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InfoReq.Marshal(b, m, deterministic)
}
func (dst *InfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoReq.Merge(dst, src)
}
func (m *InfoReq) XXX_Size() int {
	return xxx_messageInfo_InfoReq.Size(m)
}
func (m *InfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_InfoReq proto.InternalMessageInfo

type InfoRsp struct {
	Shards               []*InfoRsp_Shard `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *InfoRsp) Reset()         { *m = InfoRsp{} }
func (m *InfoRsp) String() string { return proto.CompactTextString(m) }
func (*InfoRsp) ProtoMessage()    {}
func (*InfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_searchd_b57a8c9ce0eb4055, []int{1}
}
func (m *InfoRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InfoRsp.Unmarshal(m, b)
}
func (m *InfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InfoRsp.Marshal(b, m, deterministic)
}
func (dst *InfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoRsp.Merge(dst, src)
}
func (m *InfoRsp) XXX_Size() int {
	return xxx_messageInfo_InfoRsp.Size(m)
}
func (m *InfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_InfoRsp proto.InternalMessageInfo

func (m *InfoRsp) GetShards() []*InfoRsp_Shard {
	if m != nil {
		return m.Shards
	}
	return nil
}

type InfoRsp_Shard struct {
	ID                   string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	NumDocs              uint64   `protobuf:"varint,2,opt,name=numDocs,proto3" json:"numDocs,omitempty"`
	Segments             []string `protobuf:"bytes,3,rep,name=segments,proto3" json:"segments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InfoRsp_Shard) Reset()         { *m = InfoRsp_Shard{} }
func (m *InfoRsp_Shard) String() string { return proto.CompactTextString(m) }
func (*InfoRsp_Shard) ProtoMessage()    {}
func (*InfoRsp_Shard) Descriptor() ([]byte, []int) {
	return fileDescriptor_searchd_b57a8c9ce0eb4055, []int{1, 0}
}
func (m *InfoRsp_Shard) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InfoRsp_Shard.Unmarshal(m, b)
}
func (m *InfoRsp_Shard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InfoRsp_Shard.Marshal(b, m, deterministic)
}
func (dst *InfoRsp_Shard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoRsp_Shard.Merge(dst, src)
}
func (m *InfoRsp_Shard) XXX_Size() int {
	return xxx_messageInfo_InfoRsp_Shard.Size(m)
}
func (m *InfoRsp_Shard) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoRsp_Shard.DiscardUnknown(m)
}

var xxx_messageInfo_InfoRsp_Shard proto.InternalMessageInfo

func (m *InfoRsp_Shard) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *InfoRsp_Shard) GetNumDocs() uint64 {
	if m != nil {
		return m.NumDocs
	}
	return 0
}

func (m *InfoRsp_Shard) GetSegments() []string {
	if m != nil {
		return m.Segments
	}
	return nil
}

type SearchReq struct {
	TraceID              string    `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	ShardID              string    `protobuf:"bytes,2,opt,name=shardID,proto3" json:"shardID,omitempty"`
	Query                *pb.Query `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	Start                uint64    `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	Count                uint32    `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SearchReq) Reset()         { *m = SearchReq{} }
func (m *SearchReq) String() string { return proto.CompactTextString(m) }
func (*SearchReq) ProtoMessage()    {}
func (*SearchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_searchd_b57a8c9ce0eb4055, []int{2}
}
func (m *SearchReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchReq.Unmarshal(m, b)
}
func (m *SearchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchReq.Marshal(b, m, deterministic)
}
func (dst *SearchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchReq.Merge(dst, src)
}
func (m *SearchReq) XXX_Size() int {
	return xxx_messageInfo_SearchReq.Size(m)
}
func (m *SearchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchReq.DiscardUnknown(m)
}

var xxx_messageInfo_SearchReq proto.InternalMessageInfo

func (m *SearchReq) GetTraceID() string {
	if m != nil {
		return m.TraceID
	}
	return ""
}

func (m *SearchReq) GetShardID() string {
	if m != nil {
		return m.ShardID
	}
	return ""
}

func (m *SearchReq) GetQuery() *pb.Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *SearchReq) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchReq) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type SearchRsp struct {
	Docs                 []*pb.Document `protobuf:"bytes,1,rep,name=docs,proto3" json:"docs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SearchRsp) Reset()         { *m = SearchRsp{} }
func (m *SearchRsp) String() string { return proto.CompactTextString(m) }
func (*SearchRsp) ProtoMessage()    {}
func (*SearchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_searchd_b57a8c9ce0eb4055, []int{3}
}
func (m *SearchRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchRsp.Unmarshal(m, b)
}
func (m *SearchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchRsp.Marshal(b, m, deterministic)
}
func (dst *SearchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchRsp.Merge(dst, src)
}
func (m *SearchRsp) XXX_Size() int {
	return xxx_messageInfo_SearchRsp.Size(m)
}
func (m *SearchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SearchRsp proto.InternalMessageInfo

func (m *SearchRsp) GetDocs() []*pb.Document {
	if m != nil {
		return m.Docs
	}
	return nil
}

func init() {
	proto.RegisterType((*InfoReq)(nil), "searchdpb.InfoReq")
	proto.RegisterType((*InfoRsp)(nil), "searchdpb.InfoRsp")
	proto.RegisterType((*InfoRsp_Shard)(nil), "searchdpb.InfoRsp.Shard")
	proto.RegisterType((*SearchReq)(nil), "searchdpb.SearchReq")
	proto.RegisterType((*SearchRsp)(nil), "searchdpb.SearchRsp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ tr.Server
var _ tr.ClientConn
var _ tropt.CallOption

type AdminGrpcClient interface {
	Info(ctx context.Context, in *InfoReq, opts ...tropt.CallOption) (*InfoRsp, error)
}

type adminGrpcClient struct {
	cc tr.ClientConn
}

func NewAdminGrpcClient(cc tr.ClientConn) AdminGrpcClient {
	return &adminGrpcClient{cc}
}

func (c *adminGrpcClient) Info(ctx context.Context, in *InfoReq, opts ...tropt.CallOption) (*InfoRsp, error) {
	out := new(InfoRsp)
	err := c.cc.Invoke(ctx, "/searchdpb.Admin/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type adminGrpcServiceDesc struct {
	desc *grpc.ServiceDesc
}

func (d *adminGrpcServiceDesc) Desc() interface{} {
	return d.desc
}

var AdminGrpcServiceDesc = &adminGrpcServiceDesc{&_Admin_serviceDesc}

type SearchdGrpcClient interface {
	Search(ctx context.Context, in *SearchReq, opts ...tropt.CallOption) (*SearchRsp, error)
}

type searchdGrpcClient struct {
	cc tr.ClientConn
}

func NewSearchdGrpcClient(cc tr.ClientConn) SearchdGrpcClient {
	return &searchdGrpcClient{cc}
}

func (c *searchdGrpcClient) Search(ctx context.Context, in *SearchReq, opts ...tropt.CallOption) (*SearchRsp, error) {
	out := new(SearchRsp)
	err := c.cc.Invoke(ctx, "/searchdpb.Searchd/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type searchdGrpcServiceDesc struct {
	desc *grpc.ServiceDesc
}

func (d *searchdGrpcServiceDesc) Desc() interface{} {
	return d.desc
}

var SearchdGrpcServiceDesc = &searchdGrpcServiceDesc{&_Searchd_serviceDesc}

// Reference imports to suppress errors if they are not otherwise used.
var _ context1.Context
var _ grpc1.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc1.SupportPackageIsVersion4

// AdminClient is the client API for Admin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdminClient interface {
	Info(ctx context1.Context, in *InfoReq, opts ...grpc1.CallOption) (*InfoRsp, error)
}

type adminClient struct {
	cc *grpc1.ClientConn
}

func NewAdminClient(cc *grpc1.ClientConn) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) Info(ctx context1.Context, in *InfoReq, opts ...grpc1.CallOption) (*InfoRsp, error) {
	out := new(InfoRsp)
	err := c.cc.Invoke(ctx, "/searchdpb.Admin/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServer is the server API for Admin service.
type AdminServer interface {
	Info(context1.Context, *InfoReq) (*InfoRsp, error)
}

func RegisterAdminServer(s *grpc1.Server, srv AdminServer) {
	s.RegisterService(&_Admin_serviceDesc, srv)
}

func _Admin_Info_Handler(srv interface{}, ctx context1.Context, dec func(interface{}) error, interceptor grpc1.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Info(ctx, in)
	}
	info := &grpc1.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/searchdpb.Admin/Info",
	}
	handler := func(ctx context1.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Info(ctx, req.(*InfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Admin_serviceDesc = grpc1.ServiceDesc{
	ServiceName: "searchdpb.Admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc1.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _Admin_Info_Handler,
		},
	},
	Streams:  []grpc1.StreamDesc{},
	Metadata: "searchd.proto",
}

// SearchdClient is the client API for Searchd service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SearchdClient interface {
	Search(ctx context1.Context, in *SearchReq, opts ...grpc1.CallOption) (*SearchRsp, error)
}

type searchdClient struct {
	cc *grpc1.ClientConn
}

func NewSearchdClient(cc *grpc1.ClientConn) SearchdClient {
	return &searchdClient{cc}
}

func (c *searchdClient) Search(ctx context1.Context, in *SearchReq, opts ...grpc1.CallOption) (*SearchRsp, error) {
	out := new(SearchRsp)
	err := c.cc.Invoke(ctx, "/searchdpb.Searchd/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchdServer is the server API for Searchd service.
type SearchdServer interface {
	Search(context1.Context, *SearchReq) (*SearchRsp, error)
}

func RegisterSearchdServer(s *grpc1.Server, srv SearchdServer) {
	s.RegisterService(&_Searchd_serviceDesc, srv)
}

func _Searchd_Search_Handler(srv interface{}, ctx context1.Context, dec func(interface{}) error, interceptor grpc1.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchdServer).Search(ctx, in)
	}
	info := &grpc1.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/searchdpb.Searchd/Search",
	}
	handler := func(ctx context1.Context, req interface{}) (interface{}, error) {
		return srv.(SearchdServer).Search(ctx, req.(*SearchReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Searchd_serviceDesc = grpc1.ServiceDesc{
	ServiceName: "searchdpb.Searchd",
	HandlerType: (*SearchdServer)(nil),
	Methods: []grpc1.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _Searchd_Search_Handler,
		},
	},
	Streams:  []grpc1.StreamDesc{},
	Metadata: "searchd.proto",
}

func init() { proto.RegisterFile("searchd.proto", fileDescriptor_searchd_b57a8c9ce0eb4055) }

var fileDescriptor_searchd_b57a8c9ce0eb4055 = []byte{
	// 324 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x51, 0xbb, 0x4e, 0xc3, 0x40,
	0x10, 0xe4, 0x62, 0x3b, 0xc1, 0x1b, 0x05, 0xa1, 0x25, 0xc5, 0xc9, 0x95, 0xe5, 0x02, 0x5c, 0x39,
	0x91, 0x41, 0x48, 0x94, 0x91, 0xdc, 0xb8, 0xa0, 0xe0, 0xf2, 0x05, 0x7e, 0x1c, 0x84, 0x22, 0x7e,
	0xdd, 0x59, 0x82, 0x5f, 0xa0, 0xe5, 0x87, 0xd1, 0x3d, 0x62, 0x45, 0x40, 0x37, 0x33, 0x37, 0x9a,
	0xdd, 0x9d, 0x83, 0x95, 0xe0, 0xc5, 0x50, 0x1d, 0xea, 0xa4, 0x1b, 0x5a, 0xd9, 0xa2, 0x6f, 0x69,
	0x57, 0x06, 0xf4, 0xc3, 0xe0, 0x4d, 0x57, 0x6e, 0x2c, 0x34, 0xa6, 0xc8, 0x87, 0x45, 0xde, 0xbc,
	0xb6, 0x8c, 0xf7, 0xd1, 0x17, 0xb1, 0x58, 0x74, 0xb8, 0x85, 0xb9, 0x38, 0x14, 0x43, 0x2d, 0x28,
	0x09, 0x9d, 0x78, 0x99, 0xd2, 0x64, 0x0a, 0x4b, 0xac, 0x27, 0xd9, 0x2b, 0x03, 0xb3, 0xbe, 0xe0,
	0x19, 0x3c, 0x2d, 0xe0, 0x15, 0xcc, 0xf2, 0x8c, 0x92, 0x90, 0xc4, 0x3e, 0x9b, 0xe5, 0x19, 0x52,
	0x58, 0x34, 0xe3, 0x31, 0x6b, 0x2b, 0x41, 0x67, 0x21, 0x89, 0x5d, 0x76, 0xa2, 0x18, 0xc0, 0xa5,
	0xe0, 0x6f, 0x47, 0xde, 0x48, 0x41, 0x9d, 0xd0, 0x89, 0x7d, 0x36, 0xf1, 0xe8, 0x9b, 0x80, 0xbf,
	0xd7, 0x23, 0x19, 0xef, 0x55, 0x86, 0x1c, 0x8a, 0x8a, 0x4f, 0xc1, 0x27, 0xaa, 0x5e, 0xf4, 0x02,
	0x79, 0xa6, 0xd3, 0x7d, 0x76, 0xa2, 0x78, 0x0b, 0x5e, 0x3f, 0xf2, 0xe1, 0x93, 0x3a, 0x21, 0x89,
	0x97, 0xe9, 0x75, 0x62, 0x0f, 0xef, 0xca, 0xe4, 0x45, 0xe9, 0xcc, 0x3c, 0xe3, 0x1a, 0x3c, 0x21,
	0x8b, 0x41, 0x52, 0x57, 0x6f, 0x67, 0x88, 0x52, 0xab, 0x76, 0x6c, 0x24, 0xf5, 0x42, 0x12, 0xaf,
	0x98, 0x21, 0xd1, 0xc3, 0xb4, 0x94, 0xe8, 0xf0, 0x0e, 0xdc, 0x5a, 0x5d, 0x65, 0x1a, 0xba, 0x39,
	0xcb, 0xcf, 0xda, 0x6a, 0x54, 0x67, 0x30, 0x6d, 0x48, 0x9f, 0xc0, 0xdb, 0xd5, 0xc7, 0xf7, 0x06,
	0xb7, 0xe0, 0xaa, 0xf2, 0x10, 0x7f, 0xb7, 0xc9, 0xfb, 0x00, 0xff, 0x36, 0x1c, 0x5d, 0xa4, 0x3b,
	0x58, 0x98, 0x81, 0x35, 0x3e, 0xc2, 0xdc, 0x40, 0x5c, 0x9f, 0x59, 0xa7, 0x8e, 0x82, 0x7f, 0x54,
	0x15, 0x51, 0xce, 0xf5, 0x47, 0xdf, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x79, 0x92, 0x2f, 0x57,
	0x1e, 0x02, 0x00, 0x00,
}
